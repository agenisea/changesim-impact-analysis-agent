// Retry utility with exponential backoff and jitter
async function retryWithJitter(fn, maxRetries = 3, baseDelay = 500) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      // Exponential backoff with jitter
      const delay = baseDelay * Math.pow(2, attempt);
      const jitter = Math.random() * 0.3 * delay; // 30% jitter
      const totalDelay = delay + jitter;

      console.log(`[embedding-job-processor] Attempt ${attempt + 1} failed, retrying in ${Math.round(totalDelay)}ms...`);
      await new Promise(resolve => setTimeout(resolve, totalDelay));
    }
  }
}

Deno.serve(async (req) => {
  try {
    const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
    const KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
    if (!SUPABASE_URL || !KEY) {
      console.error('[embedding-job-processor] Missing environment variables');
      return new Response("missing env", {
        status: 500
      });
    }

    // Fetch pending jobs
    const jobsRes = await fetch(`${SUPABASE_URL}/rest/v1/embedding_jobs?status=eq.pending&limit=10`, {
      headers: {
        "apikey": KEY,
        "Authorization": `Bearer ${KEY}`
      }
    });

    if (!jobsRes.ok) {
      console.error('[embedding-job-processor] Jobs query failed:', jobsRes.status);
      return new Response(JSON.stringify({
        error: 'Jobs query failed'
      }), {
        status: 500
      });
    }

    const jobs = await jobsRes.json();
    if (!Array.isArray(jobs) || jobs.length === 0) {
      return new Response(JSON.stringify({
        processed: 0
      }), {
        status: 200
      });
    }

    // Fetch chunks for jobs
    const jobsWithChunks = await Promise.all(jobs.map(async (job) => {
      const chunkRes = await fetch(`${SUPABASE_URL}/rest/v1/changesim_impact_analysis_run_chunks?chunk_id=eq.${job.chunk_id}&select=*`, {
        headers: {
          "apikey": KEY,
          "Authorization": `Bearer ${KEY}`
        }
      });

      if (!chunkRes.ok) {
        console.error(`[embedding-job-processor] Failed to fetch chunk for job ${job.id}`);
        return {
          ...job,
          chunk: null
        };
      }

      const chunks = await chunkRes.json();
      return {
        ...job,
        chunk: chunks[0] || null
      };
    }));

    // Filter valid jobs
    const validJobs = jobsWithChunks.filter((job) => job.chunk?.content);
    if (validJobs.length === 0) {
      // Mark all jobs as failed
      await Promise.all(jobs.map((job) =>
        fetch(`${SUPABASE_URL}/rest/v1/embedding_jobs?chunk_id=eq.${job.chunk_id}`, {
          method: "PATCH",
          headers: {
            "apikey": KEY,
            "Authorization": `Bearer ${KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            status: "failed"
          })
        }).catch(() => {})
      ));

      return new Response(JSON.stringify({
        processed: 0
      }), {
        status: 200
      });
    }

    const OPENAI_KEY = Deno.env.get("OPENAI_API_KEY");
    if (!OPENAI_KEY) {
      console.error('[embedding-job-processor] Missing OPENAI_API_KEY environment variable');
      return new Response(JSON.stringify({
        error: 'missing OPENAI_API_KEY'
      }), {
        status: 500
      });
    }

    console.log(`[embedding-job-processor] Processing ${validJobs.length} jobs via OpenAI embeddings`);

    // Call OpenAI with retry logic
    const embedRes = await retryWithJitter(async () => {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_KEY}`
        },
        body: JSON.stringify({
          model: 'text-embedding-3-small', // Note: Must match EMBEDDING_MODEL constant (text-embedding-3-small = 1536 dimensions)
          input: validJobs.map((job) => job.chunk.content)
        })
      });

      if (!response.ok) {
        const message = await response.text().catch(() => 'unknown error');
        throw new Error(`OpenAI API failed: ${response.status} ${message}`);
      }

      return response;
    }, 3, 1000);

    const payload = await embedRes.json();
    const vectors = Array.isArray(payload?.data) ? payload.data : [];
    const results = [];

    await Promise.all(validJobs.map(async (job, index) => {
      try {
        const embedding = vectors[index]?.embedding;
        if (!Array.isArray(embedding)) {
          throw new Error('missing embedding');
        }

        const [chunkRes, jobRes] = await Promise.all([
          fetch(`${SUPABASE_URL}/rest/v1/changesim_impact_analysis_run_chunks?chunk_id=eq.${job.chunk.chunk_id}`, {
            method: "PATCH",
            headers: {
              "apikey": KEY,
              "Authorization": `Bearer ${KEY}`,
              "Content-Type": "application/json",
              "Prefer": "return=representation"
            },
            body: JSON.stringify({
              embedding
            })
          }),
          fetch(`${SUPABASE_URL}/rest/v1/embedding_jobs?chunk_id=eq.${job.chunk_id}`, {
            method: "PATCH",
            headers: {
              "apikey": KEY,
              "Authorization": `Bearer ${KEY}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              status: "done"
            })
          })
        ]);

        if (chunkRes.ok && jobRes.ok) {
          results.push(job.chunk_id);
        } else {
          console.error(`[embedding-job-processor] Failed to update job ${job.id}: chunk ${chunkRes.status}, job ${jobRes.status}`);
          await fetch(`${SUPABASE_URL}/rest/v1/embedding_jobs?chunk_id=eq.${job.chunk_id}`, {
            method: "PATCH",
            headers: {
              "apikey": KEY,
              "Authorization": `Bearer ${KEY}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              status: "failed"
            })
          }).catch(() => {});
        }
      } catch (jobError) {
        console.error(`[embedding-job-processor] Error processing job ${job.id}:`, jobError.message);
        await fetch(`${SUPABASE_URL}/rest/v1/embedding_jobs?chunk_id=eq.${job.chunk_id}`, {
          method: "PATCH",
          headers: {
            "apikey": KEY,
            "Authorization": `Bearer ${KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            status: "failed"
          })
        }).catch(() => {});
      }
    }));

    console.log(`[embedding-job-processor] Completed: ${results.length}/${validJobs.length} successful`);
    return new Response(JSON.stringify({
      processed: results.length
    }), {
      status: 200,
      headers: {
        "Content-Type": "application/json"
      }
    });
  } catch (err) {
    console.error('[embedding-job-processor] Fatal error:', err.message);
    return new Response(JSON.stringify({
      error: err.message
    }), {
      status: 500,
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
});